-- SEQUENCE: 순차번호 자동 생성 객체(PRIMARY KEY에서 순차번호 생성이 필요한 때)
-- 순차번호(PRIMARY KEY), 친구이름, 전화, 최종수정일
-- 1 홍길동 010-9999-9999 19/12/30
-- 2 김길동 NULL          19/12/30
DROP SEQUENCE FRIEND_SEQno;
CREATE SEQUENCE FRIEND_SEQno -- 1,2,3,4,5...
    INCREMENT BY 1 -- 1씩 증가. -1을 쓰면 1씩 감소
    START WITH 5 -- 시작 숫자. 
    MAXVALUE 9999 -- 최대 숫자
    MINVALUE 1 -- -1씩 증가하거나 할때 주로 사용
    NOCYCLE -- 최대 숫자까지 가면 더이상x. CYCLE 로 하면 다시 1로 돌아감
    NOCACHE; -- NEXTVAL 할 때 순차번호 생성. (미리 만들어서 저장해놓지 않는당)

DROP TABLE FRIEND;
    
CREATE TABLE FRIEND(
    NUM NUMBER(4) PRIMARY KEY, -- 순차번호
    NAME VARCHAR2(50), -- 친구이름
    TEL VARCHAR2(30) UNIQUE, -- NULL 가능
    LAST_MODIFIED DATE DEFAULT SYSDATE); -- 최종수정일

INSERT INTO FRIEND (NUM,NAME,TEL) VALUES 
    (FRIEND_SEQno.NEXTVAL,'홍길동','010-9999-9999');
INSERT INTO FRIEND (NUM,NAME,TEL) VALUES 
    (FRIEND_SEQno.NEXTVAL,'힝길동',NULL);    
SELECT*FROM FRIEND;  
SELECT FRIEND_SEQno.CURRVAL FROM DUAL; -- 현재 시쿼스 값

-- 일반적으로(1부터 순차 증가) 이렇게 생성
CREATE SEQUENCE FRIEND_SEQ
    MAXVALUE 99999
    NOCYCLE
    NOCACHE;
    
-- VIEW (가상의 테이블)
CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP; -- 단순뷰
SELECT*FROM EMPV0 WHERE DEPTNO=20;

CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO, ENAME, JOB, DNAME FROM EMP E, DEPT D
    WHERE E.DEPTNO=E.DEPTNO; -- 복합뷰
SELECT*FROM EMPV0;

-- 부서번호가 30번 부서 직원들만 EMPv1뷰 생성
CREATE OR REPLACE VIEW EMPv1
    AS SELECT*FROM EMP WHERE DEPTNO=30;
SELECT*FROM EMPV1;
INSERT INTO EMPV1 VALUES (1111,'홍',NULL,NULL,SYSDATE,NULL,NULL,40);
SELECT*FROM EMP;

CREATE OR REPLACE VIEW EMPV1
    AS SELECT*FROM EMP WHERE DEPTNO=30
    WITH CHECK OPTION; -- 30번 부서만 W/R 가능
INSERT INTO EMPV1 VALUES (1112,'홍',NULL,NULL,SYSDATE,NULL,NULL,40); -- X
INSERT INTO EMPV1 VALUES (1112,'홍',NULL,NULL,SYSDATE,NULL,NULL,30); -- O

CREATE OR REPLACE VIEW EMPV2
    AS SELECT*FROM EMP WHERE DEPTNO=30
    WITH READ ONLY; -- 30번 부서 READ만 가능
INSERT INTO EMPV2 VALUES (1113,'홍',NULL,NULL,SYSDATE,NULL,NULL,30); -- X

-- INSERT 불가한 경우
CREATE OR REPLACE VIEW EMPV3
    AS SELECT ENAME, SAL, COMM FROM EMP;
SELECT*FROM EMPV3;
INSERT INTO EMPV3 (ENAME,SAL,COMM) VALUES ('홍',9000,5000); -- EMPNO에 NULL이 오면 안됨.

CREATE OR REPLACE VIEW SALV1
    AS SELECT EMPNO,ENAME,SAL*12 YEARSAL FROM EMP WHERE DEPTNO=10;
CREATE OR REPLACE VIEW SALV1 (ID,NAME,YEARSAL)
    AS SELECT EMPNO,ENAME,SAL*12 FROM EMP WHERE DEPTNO=10;
SELECT*FROM SALV1 WHERE YEARSAL>20000;
INSERT INTO SALV1 VALUES (1111,'김',50000); -- SAL*12는 EMP에 없는 필드라서 삽입이 안됨.
SELECT*FROM SALV1;

CREATE OR REPLACE VIEW DEPTV1 (DEPTNO,MINSAL,MAXSAL,AVGSAL)
    AS SELECT DEPTNO,MIN(SAL), MAX(SAL), AVG(SAL) FROM EMP GROUP BY DEPTNO;
SELECT*FROM DEPTV1;

CREATE OR REPLACE VIEW JOBLIST
    AS SELECT DISTINCT JOB, DEPTNO FROM EMP; 
SELECT*FROM JOBLIST;    

-- INLINE VIEW : FROM 절의 SUB QUERY
-- 급여가 2000을 초과하는 사원의 평균 급여 출력
SELECT AVG(SAL) FROM (SELECT SAL FROM EMP WHERE SAL>2000);
-- 이름, 급여, 부서번호, 해당 사원의 부서급여평균 출력
SELECT ENAME, SAL, DEPTNO, (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO)FROM EMP E;
    -- INLINE VIEW를 활용하면,
    DELETE FROM EMP WHERE DEPTNO=40;
    DELETE FROM EMP WHERE ENAME='홍';
    COMMIT;
    SELECT E.ENAME, E.SAL, E.DEPTNO, S.DEPTNO,S.AVGSAL
        FROM EMP E, (SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) S
        WHERE E.DEPTNO=S.DEPTNO;
-- 이름, 급여, 부서번호, 부서급여 평균을 출력 (부서 평균보다 많이 받는 사원만 출력)
SELECT ENAME, SAL, S.DEPTNO, AVGSAL
   FROM EMP, (SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) S
   WHERE EMP.DEPTNO=S.DEPTNO AND
       EMP.SAL>S.AVGSAL;

-- TOP-N 구문
SELECT ROWNUM, ENAME, SAL FROM EMP;
SELECT ROWNUM, DEPTNO, DNAME FROM DEPT; -- ROWNUM은 테이블에서 가져온 순서
-- SAL 등수, ENAME, SAL
SELECT ROWNUM, ENAME, SAL FROM EMP ORDER BY SAL; -- ROWNUM이 등수가 아님 
SELECT ROWNUM, ENAME, SAL FROM (SELECT*FROM EMP ORDER BY SAL)
    WHERE ROWNUM<6; -- TOP 1~5
SELECT ROWNUM, ENAME, SAL FROM (SELECT*FROM EMP ORDER BY SAL)
    WHERE ROWNUM BETWEEN 6 AND 10; -- TOP 6~10 (X) 번호 1이 없으면 계속 1을 만들어내는데 조건이 6부터니까 다 날라가벌임
SELECT RN, ENAME, SAL FROM (SELECT ROWNUM RN, A.* FROM (SELECT*FROM EMP ORDER BY SAL) A)
    WHERE RN BETWEEN 6 AND 10; -- TOP 6~10 (O) -- RN이 아닌 레알 ROWNUM으로 하면 레알 ROWNUM 식 번호 붙이기를 하믄서 다 버려버림.. 

SELECT RANK() OVER(ORDER BY SAL) RANK,
       DENSE_RANK() OVER(ORDER BY SAL) D_RANK,
       ROW_NUMBER() OVER(ORDER BY SAL) R_RANK, ENAME, SAL FROM EMP;
       
-- 1. 부서명과 사원명을 출력하는 용도의 뷰, DNAME_ENAME_VU 를 작성하시오
CREATE OR REPLACE VIEW DNAME_ENAME_VU
    AS SELECT DNAME, ENAME 
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO;
SELECT*FROM DNAME_ENAME_VU;

-- 2. 사원명과 직속상관명을 출력하는 용도의 뷰,  WORKER_MANAGER_VU를 작성하시오
CREATE OR REPLACE VIEW WORKER_MANAGER_VU (WORKER, MANAGER)
    AS SELECT W.ENAME, M.ENAME
    FROM EMP W, EMP M
    WHERE W.MGR=M.EMPNO(+);
SELECT*FROM WORKER_MANAGER_VU;

-- 3. 부서별 급여합계 등수를 출력하시오(부서번호, 급여합계, 등수) ? 친구출제
SELECT ROWNUM, DEPTNO, SUMSAL FROM (SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUM(SAL) DESC);

-- 4. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 순으로 정렬하시오
SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC;

-- 5. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 5명을 출력하시오
SELECT EMPNO, ENAME, HIREDATE FROM (SELECT EMPNO, ENAME,HIREDATE FROM EMP ORDER BY HIREDATE DESC)
    WHERE ROWNUM<6;
    
-- 6. 사원 테이블에서 사번, 사원명, 입사일을 최신부터 오래된 순으로 6번째로 늦은 사원부터 10번째 사원까지 출력
SELECT EMPNO, ENAME, HIREDATE FROM (SELECT ROWNUM RN, A.* FROM (SELECT*FROM EMP ORDER BY HIREDATE DESC)A)
    WHERE RN BETWEEN 6 AND 10;



    
    
    
    