-- VI. SUB QUERY
-- SCOTT 이 근무하는 부서이름?
SELECT DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='SCOTT'; -- JOIN
SELECT DNAME FROM DEPT WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'); -- 메인쿼리
SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'; -- 서브쿼리. *실행순서 : 서브쿼리->메인쿼리

-- 서브쿼리의 종류 : 단일행 서브쿼리, 다중행 서브쿼리
-- JOB이 MANAGER 인 사람의 부서이름
SELECT DEPTNO FROM EMP WHERE JOB='MANAGER'; -- (다중행) 서브쿼리
SELECT DNAME FROM DEPT WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE JOB='MANAGER');

-- (1) 단일행 서브쿼리
SELECT MAX(SAL) FROM EMP; -- 최고 금액 SAL
SELECT ENAME, SAL FROM EMP WHERE SAL=(SELECT MAX(SAL) FROM EMP); -- 최고금액 받는 사람이름, 최고SAL
SELECT ENAME FROM EMP WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT') AND ENAME<>'SCOTT';-- SCOTT과 같은 부서의 사람들 뿌려랏

INSERT INTO DEPT VALUES (50,'IT','DALLAS');
INSERT INTO EMP VALUES (9999,'홍길동',NULL,NULL,NULL,9000,NULL,50);
ROLLBACK;  -- INSERT 취소

 SELECT ENAME FROM EMP E,DEPT D
    WHERE E.DEPTNO=D.DEPTNO
        AND LOC=(SELECT LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='SCOTT')
        AND ENAME<>'SCOTT';-- SCOTT과 같은 근무지에 근무하는 사람들 이름
        
-- SCOTT과 같은 JOB을 가진 사람의 모든 정보
SELECT * FROM EMP WHERE JOB=(SELECT JOB FROM EMP WHERE ENAME='SCOTT');     

-- SCOTT과 급여가 동일하거나 더 많이 받는 사원의 이름과 급여
SELECT ENAME, SAL FROM EMP WHERE SAL>=(SELECT SAL FROM EMP WHERE ENAME='SCOTT');

-- 직속상관이 KING인 사원의 이름과 급여
SELECT ENAME, SAL FROM EMP WHERE MGR=(SELECT EMPNO FROM EMP WHERE ENAME='KING'); 

-- 평균 급여 이하를 받는 직원의 사번, 이름, 급여
SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL<=(SELECT AVG(SAL) FROM EMP);

-- 부서 별 최대 급여, 그 최대 급여를 받는 사람의 이름, 그 사람의 급여
SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO; -- 서브쿼리
SELECT DEPTNO, SAL, ENAME FROM EMP 
    WHERE (DEPTNO,SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO); -- 다중열, 다중행

-- 단일행 다중행 서브쿼리 : SCOTT과 JOB도 같고, 부서 번호도 같은 사람의 모든 필드를 출력
SELECT * FROM EMP 
    WHERE (JOB,DEPTNO)=(SELECT JOB, DEPTNO FROM EMP 
                            WHERE ENAME='SCOTT') AND ENAME<>'SCOTT';
                            
-- (2) 다중행 서브쿼리 : 서브쿼리의 실행결과가 다중행 IN, ALL, ANY=SOME, EXISTS
-- DEPTNO, DEPTNO 별 최대 급여, 최대 급여 받는 사람 이름 출력
SELECT DEPTNO, SAL, ENAME FROM EMP 
    WHERE(DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);
    
-- 입사년도, 입사년 별 최소급여, 받는 사람 이름
SELECT TO_CHAR(HIREDATE, 'YY') YEAR, SAL, ENAME FROM EMP
    WHERE(TO_CHAR(HIREDATE, 'YY'),SAL)
    IN (SELECT TO_CHAR(HIREDATE, 'YY'), MIN(SAL) FROM EMP GROUP BY TO_CHAR(HIREDATE, 'YY'))
    ORDER BY YEAR;

-- 급여가 3000 이상 받는 사원이 소속된 부서와 동일한 부서에서 근무하는 사원들의 모든 필드
SELECT DEPTNO FROM EMP WHERE SAL>=3000;
SELECT * FROM EMP 
    WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE SAL>=3000);

-- 부서 별로 입사일이 가장 늦은 사람의 부서번호, 이름, 입사일을 출력
SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO;
SELECT DEPTNO, ENAME, HIREDATE FROM EMP WHERE(DEPTNO, HIREDATE) IN (SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO);

-- JOB 별 가장 낮은 연봉을 받는 사람의 이름, JOB, 연봉
SELECT JOB, MIN(SAL) FROM EMP GROUP BY JOB;
SELECT ENAME, JOB, SAL FROM EMP
    WHERE (JOB,SAL) IN (SELECT JOB, MIN(SAL) FROM EMP GROUP BY JOB);

-- 30번 부서 사원 중 급여가 가장 많은 사원보다 더 많은 급여를 받는 사람의 이름, 급여
-- > 다중행으로 풀어보면,
SELECT SAL FROM EMP WHERE DEPTNO=30; -- 다중행 서브쿼리
SELECT ENAME, SAL FROM EMP 
    WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO=30);
-- 또는
SELECT ENAME, SAL FROM EMP 
    WHERE SAL>(SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);
    
-- 30번 부서 사원 급여 중 가장 작은 값 보다 많은 급여를 많은 사원의 이름, 급여
SELECT ENAME, SAL FROM EMP
    WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO=30);
SELECT ENAME, SAL FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO=30);

-- 직속 부하가 있는 직원의 사원번호, 이름, 급여 출력
SELECT EMPNO, ENAME, SAL FROM EMP WHERE EMPNO IN (SELECT MGR FROM EMP);
-- > EXISTS를 쓴다면~
SELECT EMPNO, ENAME, SAL FROM EMP MANAGER
    WHERE EXISTS (SELECT EMPNO FROM EMP WORKER WHERE WORKER.MGR=MANAGER.EMPNO);
SELECT EMPNO, ENAME, SAL FROM EMP MANAGER
    WHERE EXISTS (SELECT EMPNO FROM EMP WHERE MGR=MANAGER.EMPNO);
    
-- 사번, 이름, 부서번호, SAL, 직원 별 부서의 SAL 평균(SELECT 절에 SUBQUERY)
SELECT EMPNO, ENAME, DEPTNO, SAL, (SELECT ROUND(AVG(SAL)) FROM EMP WHERE DEPTNO=E.DEPTNO) "급여평균" FROM EMP E 
    ORDER BY DEPTNO, SAL DESC;
    
-- 직속 부하가 없는 직원의 모든 정보를 출력
-- EXISTS 연산자 이용
SELECT * FROM EMP MANAGER
    WHERE NOT EXISTS(SELECT EMPNO FROM EMP WORKER WHERE WORKER.MGR=MANAGER.EMPNO);
-- IN 연산자 이용
SELECT * FROM EMP WHERE EMPNO NOT IN (SELECT MGR FROM EMP WHERE MGR IS NOT NULL);
-- SELF JOIN, OUTER JOIN
SELECT M.* FROM EMP W, EMP M WHERE W.MGR(+)=M.EMPNO AND W.ENAME IS NULL;

-- <탄탄다지기>
--부서별로 가장 급여를 많이 받는 사원의 정보(사원 번호, 사원이름, 급여, 부서번호)를 출력(IN 연산자 이용)
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP
    WHERE (DEPTNO,SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);
    
--직급(JOB)이 MANAGER인 사람의 속한 부서의 부서 번호와 부서명과 지역을 출력(IN)
SELECT E.DEPTNO, DNAME, LOC FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
    AND ENAME IN (SELECT ENAME FROM EMP WHERE JOB='MANAGER');
    
SELECT DEPTNO, DNAME, LOC FROM DEPT
    WHERE DEPTNO
    IN (SELECT DEPTNO FROM EMP WHERE JOB='MANAGER');

--연봉이 3000이상인 사람들 중 연봉 등급을 나누어서 해당 등급별 최고 연봉을 받는 사람들의 사번, 이름, 직업, 입사일, 급여, 급여등급을 출력
SELECT EMPNO, ENAME, JOB, HIREDATE, SAL, GRADE FROM EMP, SALGRADE
    WHERE SAL BETWEEN LOSAL AND HISAL
    AND (GRADE,SAL) IN (SELECT GRADE, MAX(SAL) FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL AND SAL>=3000 GROUP BY GRADE);
    
--응용심화 : 입사일 분기별로 가장 높은 연봉을 받는 사람들의 분기, 사번, 이름, JOB, 상사사번, 입사일, 급여, 상여를 출력하세요

SELECT HIREDATE, CEIL(EXTRACT(MONTH FROM HIREDATE)/3) QUARTER FROM EMP; -- 분기
SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) 분기, MAX(SAL) FROM EMP GROUP BY CEIL(EXTRACT(MONTH FROM HIREDATE)/3); -- 서브쿼리(분기 별 가장 높은 연봉)

SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) 분기, EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMMㅔ
    FROM EMP
    WHERE (CEIL(EXTRACT(MONTH FROM HIREDATE)/3),SAL)
    IN (SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) 분기, MAX(SAL) FROM EMP GROUP BY CEIL(EXTRACT(MONTH FROM HIREDATE)/3))
    ORDER BY 분기;

--SALESMAN 모든 사원들 보다 급여를 많이 받는 사원들의 이름과 급여와 직급(담당 업무)를 출력하되 영업 사원은 출력하지 않는다.(ALL이용)
SELECT ENAME, SAL, JOB FROM EMP WHERE SAL > ALL (SELECT SAL FROM EMP WHERE JOB='SALESMAN');

--SALESMAN 일부 어떤 한 사원보다 급여를 많이 받는 사원들의 이름과 급여와 직급(담당 업무)를 출력하되 영업 사원 포함해서 출력(ANY)
SELECT ENAME, SAL, JOB FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE JOB='SALESMAN');

--연봉이 3000미만인 사람 중에 가장 최근에 입사한 사람의 사원번호와 이름, 연봉, 입사일을 출력
SELECT EMPNO, ENAME, SAL, HIREDATE FROM EMP WHERE HIREDATE=(SELECT MAX(HIREDATE) FROM EMP WHERE SAL<3000);

--직급이 ‘SALESMAN’인 사원이 받는 급여의 최소 급여보다 많이 받는 사원들의 이름, 급여, 직급, 부서번호를 출력하되 부서번호가 20번인 사원은 제외한다(ANY 연산자 이용)
SELECT ENAME, SAL, JOB, DEPTNO FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE JOB='SALESMAN') AND DEPTNO<>20;
SELECT ENAME, SAL, JOB, DEPTNO FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE JOB='SALESMAN') AND DEPTNO<>20;
    
-- ★ 셤 연습문제
-- 1. 사원테이블에서 가장 먼저 입사한 사람의 이름, 급여, 입사일
SELECT ENAME, SAL, HIREDATE FROM EMP WHERE HIREDATE=(SELECT MIN(HIREDATE) FROM EMP);

-- 2. 회사에서 가장 급여가 적은 사람의 이름, 급여
SELECT ENAME, SAL FROM EMP WHERE SAL=(SELECT MIN(SAL) FROM EMP);

-- 3. 회사 평균보다 급여를 많이 받는 사람의 이름, 급여, 부서코드
SELECT ENAME, SAL, DEPTNO FROM EMP WHERE SAL>(SELECT AVG(SAL) FROM EMP);

-- 4. 회사 평균 이하의 급여를 받는 사람의 이름, 급여, 부서명
SELECT ENAME, SAL, DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO 
    AND SAL<=(SELECT AVG(SAL) FROM EMP);
    
-- 5. SCOTT보다 먼저 입사한 사람의 이름, 급여, 입사일, 급여 등급
SELECT ENAME, SAL, HIREDATE, GRADE FROM EMP, SALGRADE
    WHERE SAL BETWEEN LOSAL AND HISAL
    AND HIREDATE<(SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT');
    
-- 6. 5번에 부서명 추가하고 급여가 큰 순 정렬
SELECT ENAME, SAL, HIREDATE, GRADE, DNAME FROM EMP E, SALGRADE, DEPT D 
    WHERE (SAL BETWEEN LOSAL AND HISAL)
    AND E.DEPTNO=D.DEPTNO
    AND HIREDATE<(SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT')
    ORDER BY SAL DESC;

-- 7. 사원테이블에서 BLAKE 보다 급여가 많은 사원들의 사번, 이름, 급여를 검색
SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL>(SELECT SAL FROM EMP WHERE ENAME='BLAKE');

-- 8. 사원테이블에서 MILLER보다 늦게 입사한 사원의 사번, 이름, 입사일을 검색하시오
SELECT EMPNO, ENAME, HIREDATE FROM EMP WHERE HIREDATE>(SELECT HIREDATE FROM EMP WHERE ENAME='MILLER');

-- 9. 사원테이블에서 사원전체 평균 급여보다 급여가 많은 사원들의 사번, 이름, 급여를 검색
SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL>(SELECT AVG(SAL) FROM EMP);

-- 10. 사원테이블에서 CLARK와 같은 부서며, 사번이 7698인 직원의 급여보다 많은 급여를 받는 사원들의 사번, 이름, 급여 검색
SELECT EMPNO, ENAME, SAL FROM EMP 
    WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='CLARK') AND SAL>(SELECT SAL FROM EMP WHERE EMPNO=7698);

-- 11. 응용심화. 사원테이블에서 CLARK와 같은 부서명이며, 사번이 7698인 직원의 급여보다 많은 급여를 받는 사원들의 사번, 이름, 급여 검색
SELECT EMPNO, ENAME, SAL FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO
    AND DNAME=(SELECT DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='CLARK')
    AND SAL>(SELECT SAL FROM EMP WHERE EMPNO=7698);
    
--12. 사원 테이블에서 BLAKE와 같은 부서에 있는 모든 사원의 이름과 입사일자를 출력하는 SELECT문을 작성하시오.
SELECT ENAME, HIREDATE FROM EMP WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='BLAKE') AND ENAME<>'BLAKE';

-- 13. 사원 테이블에서 평균 급여 이상을 받는 모든 종업원에 대해서 종업원 번호와 이름을 출력하는 SELECT문을 작성하시오. (단 급여가 많은 순으로 출력하여라.)
SELECT EMPNO, ENAME FROM EMP WHERE SAL>=(SELECT AVG(SAL) FROM EMP) ORDER BY SAL DESC;

-- 14. 사원 테이블에서 이름에 “T”가 있는 사원이 근무하는 부서에서 근무하는 모든 종업원에 대해 
-- 사원 번호,이름,급여를 출력하는 SELECT문을 작성하시오. 단 사원번호 순으로 출력하여라.
SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE ENAME LIKE '%T%');

-- 15.	사원 테이블에서 사원명의 세 번째 알파벳이 'N'인 사원의 사번, 사원명을 검색하시오
SELECT EMPNO, ENAME FROM EMP WHERE ENAME IN (SELECT ENAME FROM EMP WHERE ENAME LIKE '__N%');






















